[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Python Best Practices",
    "section": "",
    "text": "Following best practice guidelines requires extra effort, so why should we spend more time ensuring a project meets the requirements?\n\n\n\n\n\n\n\n\nCollaboration\n\n\n\nIt is easier for others, and your future self, to understand your work.\n\n\n\n\n\n\n\n\n\n\nAccuracy\n\n\n\nCode has fewer bugs, and everyone has more confidence about the results.\n\n\n\n\n\n\n\n\n\n\nReliability\n\n\n\nCode is more likely to run consistently across users and over time.\n\n\n\n\n\n\n\n\n\n\nMaintenance\n\n\n\nMaking future changes, and fixing bugs, is much easier and quicker.\n\n\n\n\n\n\n\n\n\n\nSecurity\n\n\n\nWho can view and edit the code and data is controlled, and everything is backed up.\n\n\n\n\n\n\n\n\n\n\nRegulatory\n\n\n\nThe Bank of England identifies end-user computing as a risk that should be controlled.",
    "crumbs": [
      "Coding Standards",
      "Python Best Practices"
    ]
  },
  {
    "objectID": "index.html#motivation",
    "href": "index.html#motivation",
    "title": "Python Best Practices",
    "section": "",
    "text": "Following best practice guidelines requires extra effort, so why should we spend more time ensuring a project meets the requirements?\n\n\n\n\n\n\n\n\nCollaboration\n\n\n\nIt is easier for others, and your future self, to understand your work.\n\n\n\n\n\n\n\n\n\n\nAccuracy\n\n\n\nCode has fewer bugs, and everyone has more confidence about the results.\n\n\n\n\n\n\n\n\n\n\nReliability\n\n\n\nCode is more likely to run consistently across users and over time.\n\n\n\n\n\n\n\n\n\n\nMaintenance\n\n\n\nMaking future changes, and fixing bugs, is much easier and quicker.\n\n\n\n\n\n\n\n\n\n\nSecurity\n\n\n\nWho can view and edit the code and data is controlled, and everything is backed up.\n\n\n\n\n\n\n\n\n\n\nRegulatory\n\n\n\nThe Bank of England identifies end-user computing as a risk that should be controlled.",
    "crumbs": [
      "Coding Standards",
      "Python Best Practices"
    ]
  },
  {
    "objectID": "index.html#best-practices",
    "href": "index.html#best-practices",
    "title": "Python Best Practices",
    "section": "Best Practices",
    "text": "Best Practices\nIn order to realise the benefits of using best practices, there are six areas to consider when creating, or updating, a project.\n\n\n\n\n\n\n\n\nCoding Standards\n\n\n\nFollowing coding standards makes projects easier to read and understand. Well-written code reduces the time to handover to others and for them to modify it.\n\n\n\n\n\n\n\n\n\n\nDocumentation\n\n\n\nDocumentation ensures everyone understands the code’s purpose, what it does and how to use it effectively.\n\n\n\n\n\n\n\n\n\n\nTesting\n\n\n\nTesting ensures the code actually does what it intended. Test results should be recorded as evidence and repeated whenever any changes are made.\n\n\n\n\n\n\n\n\n\n\nReproducibility\n\n\n\nResults should be reproducible by others, and your future self. This means keeping track of inputs, parameters, code and packages used to produce the same results.\n\n\n\n\n\n\n\n\n\n\nChange Control\n\n\n\nChanges to code are inevitable and should be managed. Changes must be understood by all parties, agreed, reviewed and approved. It should also be possible to easily revert changes.\n\n\n\n\n\n\n\n\n\n\nAccess Control\n\n\n\nThere should be controls on who has acccess to the code and who can execute it. Any storage used should have appropriate backup and disaster recovery in place.",
    "crumbs": [
      "Coding Standards",
      "Python Best Practices"
    ]
  },
  {
    "objectID": "index.html#application",
    "href": "index.html#application",
    "title": "Python Best Practices",
    "section": "Application",
    "text": "Application\nThe degree to which the above points need to be addressed depends on the importance of the work. A process or application that is critical to reporting results to a regulator is subjected to more controls than a simple analysis that does not go beyond the team.\nBefore we can decide what level of controls are required, we must assess the criticality of the project. Once the assessment is complete, the pages for each area of best practice (linked above) describe the minimum standards. The following can be used as a guide when assessing the criticality of a piece of work. If any of the bullets are true, then the project meets that level of assessment.\n\n\n\n\n\n\n\n\nLow Criticality\n\n\n\n\nSimple script of limited scope.\nNo dependencies, other than external packages.\nNot used for decision making.\nNot used outside the team.\nDoes not use sensitive data.\n\n\n\n\n\n\n\n\n\n\n\nMedium Criticality\n\n\n\n\nSmall project of a few scripts.\nA few upstream or downstream dependencies.\nUsed for team decision making.\nUsed by other teams.\nUses sensitive data.\n\n\n\n\n\n\n\n\n\n\n\nHigh Criticality\n\n\n\n\nLarge project or package of Multiple scripts.\nMany upstream or downstream dependencies.\nUsed for senior leadership / executive decision making.\nUsed externally or for regulatory purposes.\nUses personal data.",
    "crumbs": [
      "Coding Standards",
      "Python Best Practices"
    ]
  },
  {
    "objectID": "documentation/projects.html",
    "href": "documentation/projects.html",
    "title": "Projects",
    "section": "",
    "text": "MkDocs is a fast, simple, and beautiful static site generator geared towards building project documentation. It uses Markdown for content, making it easy to write and maintain. This article guides you through setting up MkDocs and using it to document your Python project.\n\n\nIt is recommended you install mkdocs with uv into the dev group. You can do this in Powershell using:\nuv add --dev mkdocs \"mkdocstrings[python]\" mkdocs-material\n\nmkdocstrings[python] is a plugin that automatically generates API documentation from your Python code’s docstrings.\nmkdocs-material is a highly recommended theme that provides a modern and responsive look.\n\n\n\n\nNavigate to your project’s root directory in the terminal and initialize MkDocs:\nmkdocs new . # The '.' creates the config files in the current directory\nThis creates two important files:\n\nmkdocs.yml: The main configuration file for MkDocs.\ndocs/index.md: The main page of your documentation.",
    "crumbs": [
      "Coding Standards",
      "Documentation",
      "Projects"
    ]
  },
  {
    "objectID": "documentation/projects.html#documentating-projects-with-mkdocs",
    "href": "documentation/projects.html#documentating-projects-with-mkdocs",
    "title": "Projects",
    "section": "",
    "text": "MkDocs is a fast, simple, and beautiful static site generator geared towards building project documentation. It uses Markdown for content, making it easy to write and maintain. This article guides you through setting up MkDocs and using it to document your Python project.\n\n\nIt is recommended you install mkdocs with uv into the dev group. You can do this in Powershell using:\nuv add --dev mkdocs \"mkdocstrings[python]\" mkdocs-material\n\nmkdocstrings[python] is a plugin that automatically generates API documentation from your Python code’s docstrings.\nmkdocs-material is a highly recommended theme that provides a modern and responsive look.\n\n\n\n\nNavigate to your project’s root directory in the terminal and initialize MkDocs:\nmkdocs new . # The '.' creates the config files in the current directory\nThis creates two important files:\n\nmkdocs.yml: The main configuration file for MkDocs.\ndocs/index.md: The main page of your documentation.",
    "crumbs": [
      "Coding Standards",
      "Documentation",
      "Projects"
    ]
  },
  {
    "objectID": "documentation/projects.html#configuring-mkdocs.yml",
    "href": "documentation/projects.html#configuring-mkdocs.yml",
    "title": "Projects",
    "section": "3. Configuring mkdocs.yml",
    "text": "3. Configuring mkdocs.yml\nOpen mkdocs.yml and configure it according to your project’s needs. Here’s a basic configuration:\nsite_name: Python Project\nsite_url: \"https://pages/github/mrc/python-project/\"\nrepo_url: \"https://github/mrc/python-project/\"\ndocs_dir: mkdocs\nsite_dir: docs\n\ntheme:\n  name: material\n\nnav:\n  - index.md\n  - setup-guide.md\n  - how-to-use.md\n  - reference.md\n\nplugins:\n  - search\n  - mkdocstrings:\n      handlers:\n        python:\n          options:\n            docstring_style: numpy\nKey configuration options:\n\nsite_name: The name of your project.\nsite_url: The URL where your documentation will be hosted.\nrepo_url: The URL of your project’s repository.\ntheme: Specifies the theme to use (material is highly recommended).\nnav: Defines the navigation menu of your documentation.\nplugins: Enables plugins like the search plugin. mkdocstrings is required to extract function and class documentation from docstrings.\n\n\n4. Writing Documentation in Markdown\nEdit the docs/index.md file to write the main content of your documentation. You can use standard Markdown syntax. The index page should provide an overview of your project, very similar (or identical) to the README.\nIf the README is getting large, it is a good idea to split it up into smaller articles. Each one can be saved as a separate markdown file in the docs folder. Make sure you remember to add it to the nav in the configuration file, so a user can navigate to it.\n\n\n5. Rendering Docstrings\nAPI Reference documentation can be rendered by using ::: followed by the path. For example, if you have implemented a function called add() with a docstring in /calculator/calculations.py, you can render the documentation in a markdown document using:\n## `add()`\n::: calculator.calculations.add\nIn addition to functions, classes and methods, docstrings can be used to document modules and packages. Module documenation should be added to the top of the file and describe the functions and classes in that script. For example:\n# calculator/calculations.py\n\n\"\"\"\nProvide several sample math calculations.\n\nThis module allows the user to make mathematical calculations.\n\nExamples\n--------\n&gt;&gt;&gt; from calculator import calculations\n&gt;&gt;&gt; calculations.add(2, 4)\n6.0\n&gt;&gt;&gt; calculations.multiply(2.0, 4.0)\n8.0\n&gt;&gt;&gt; from calculator.calculations import divide\n&gt;&gt;&gt; divide(4.0, 2)\n2.0\n\nThe module contains the following functions:\n\n- `add(a, b)` - Returns the sum of two numbers.\n- `subtract(a, b)` - Returns the difference of two numbers.\n- `multiply(a, b)` - Returns the product of two numbers.\n- `divide(a, b)` - Returns the quotient of two numbers.\n\"\"\"\nThe above docstring, and all the function/class docstrings can then be reference in a markdown document using:\n::: calculator.calculations\nFinally, package documentation should be written in the top-level init.py file. This should summarise the entire package. For example:\n# calculator/__init__.py\n\n\"\"\"\nDo math with your own functions.\n\nModules exported by this package:\n\n- `calculations`: Provide several sample math calculations.\n\"\"\"\nThe above docstring can be rendered into a markdown document using:\n::: calculator\n\n\n6. Building and Serving the Documentation\nTo build the documentation, run:\nmkdocs build\nThis will generate the static site in the site directory. To serve the documentation locally for development, run:\nmkdocs serve\nThis starts a local development server that automatically reloads the documentation when you make changes.\n\n\n7. Deploying the Documentation\nThere are several ways to deploy your MkDocs documentation:\n\nGitHub Pages: A simple option for hosting static websites directly from your GitHub repository. Just set the pages options in GitHub to the ‘site’ folder. This is useful for bleeding edge development documentation.\nPosit Connect: Posit Connect can host static websites. The can be deployed from the UI. This is better for released documentation.",
    "crumbs": [
      "Coding Standards",
      "Documentation",
      "Projects"
    ]
  },
  {
    "objectID": "documentation/projects.html#example-project-structure",
    "href": "documentation/projects.html#example-project-structure",
    "title": "Projects",
    "section": "Example Project Structure",
    "text": "Example Project Structure\nmy-project/\n├── src\n|   ├── my_package/\n│   ├── __init__.py\n│   └── my_module.py\n├── mkdocs.yml\n├── docs/\n│   ├── index.md\n|   ├── setup-guide.md\n|   └── how-to-use.md\n└── setup.py\nBy following these steps, you can quickly and easily create beautiful and functional documentation for your Python projects using MkDocs and Markdown. The combination of simple Markdown syntax and powerful features like automatic API documentation makes MkDocs a great choice for many projects.",
    "crumbs": [
      "Coding Standards",
      "Documentation",
      "Projects"
    ]
  },
  {
    "objectID": "documentation/markdown.html",
    "href": "documentation/markdown.html",
    "title": "Markdown",
    "section": "",
    "text": "Markdown is a lightweight markup language that allows you to format plain text easily and efficiently. Its simple syntax makes it ideal for writing everything from quick notes and emails to comprehensive documentation and website content. This article will guide you through the essentials of Markdown, empowering you to create clean, readable, and well-structured documents.",
    "crumbs": [
      "Coding Standards",
      "Documentation",
      "Markdown"
    ]
  },
  {
    "objectID": "documentation/markdown.html#what-is-markdown",
    "href": "documentation/markdown.html#what-is-markdown",
    "title": "Markdown",
    "section": "What is Markdown?",
    "text": "What is Markdown?\nMarkdown is designed with two core goals: readability and ease of writing. A Markdown-formatted document should be easily readable in its raw form, while also being simple to convert into HTML (or other formats). This makes it perfect for writing content that needs to be both human-readable and machine-processable.",
    "crumbs": [
      "Coding Standards",
      "Documentation",
      "Markdown"
    ]
  },
  {
    "objectID": "documentation/markdown.html#basic-syntax",
    "href": "documentation/markdown.html#basic-syntax",
    "title": "Markdown",
    "section": "Basic Syntax",
    "text": "Basic Syntax\n\nHeadings: Use # symbols to create headings. The number of # symbols corresponds to the heading level:\n# Heading 1\n## Heading 2\n### Heading 3\n#### Heading 4\n##### Heading 5\n###### Heading 6\nEmphasis:\n\nItalics: Use single asterisks * or underscores _: *This text is italicized* or _This text is italicized_.\nBold: Use double asterisks ** or underscores __: **This text is bold** or __This text is bold__.\nBold Italics: Use triple asterisks *** or underscores ___: ***This text is bold and italicized*** or ___This text is bold and italicized___.\n\nLists:\n\nUnordered Lists: Use asterisks *, plus signs +, or hyphens -:\n*   Item 1\n*   Item 2\n*   Item 3\n\n+   Item A\n+   Item B\n\n-   Item X\n-   Item Y\nOrdered Lists: Use numbers followed by a period:\n1.  First item\n2.  Second item\n3.  Third item\n\nLinks: Use square brackets [] for the link text and parentheses () for the URL:\n[Link to Google](https://www.google.com)\nYou can also use inline link references:\n[Link text][link_id]\n\n[link_id]: https://www.google.com\nImages: Similar to links, but with an exclamation mark ! at the beginning:\n![Alt text](image.jpg)\nOr with a reference:\n![Alt text][image_id]\n\n[image_id]: image.jpg\nCode:\n\nInline Code: Use backticks `: `inline code`.\nCode Blocks: Use triple backticks ``` on separate lines:\n```python\nprint(\"Hello, world!\")\n```\nYou can specify the language after the opening backticks for syntax highlighting:\n```javascript\nconsole.log(\"Hello, world!\");\n```\n\nBlockquotes: Use the &gt; symbol:\n&gt; This is a blockquote.\n&gt; It can span multiple lines.\nHorizontal Rules: Use three or more asterisks ***, hyphens ---, or underscores ___ on a separate line:\n***\n---\n___\nEscaping Characters: If you need to use a character that has special meaning in Markdown (like *, #, or \\), you can escape it with a backslash \\: \\*This will not be italicized\\*.",
    "crumbs": [
      "Coding Standards",
      "Documentation",
      "Markdown"
    ]
  },
  {
    "objectID": "documentation/markdown.html#working-with-markdown-files",
    "href": "documentation/markdown.html#working-with-markdown-files",
    "title": "Markdown",
    "section": "Working with Markdown Files",
    "text": "Working with Markdown Files\n\nText Editors: Many text editors have built-in Markdown support or offer plugins for enhanced functionality (e.g., VS Code, RStudio and Positron).\nOnline Markdown Editors: Several online editors provide a live preview of your Markdown as you type (e.g., Dillinger, StackEdit).\nMarkdown Converters: Tools like Pandoc can convert Markdown to other formats like HTML, PDF, and Word documents.\nCombining Markdown With Code: Tools like Quarto combine markdown with executable code. The code “chunks” are replaced with the result before rendering the markdown.",
    "crumbs": [
      "Coding Standards",
      "Documentation",
      "Markdown"
    ]
  },
  {
    "objectID": "documentation/markdown.html#common-use-cases",
    "href": "documentation/markdown.html#common-use-cases",
    "title": "Markdown",
    "section": "Common Use Cases",
    "text": "Common Use Cases\n\nDocumentation: Writing documentation for software projects, APIs, and other technical materials.\nWriting Blog Posts and Articles: Creating content for websites and blogs.\nTaking Notes: Quickly jotting down notes and ideas.\nEmails and Messages: Formatting emails and messages in online forums and chat applications.\nCreating Presentations: Some tools allow you to create presentations from Markdown.",
    "crumbs": [
      "Coding Standards",
      "Documentation",
      "Markdown"
    ]
  },
  {
    "objectID": "documentation/markdown.html#conclusion",
    "href": "documentation/markdown.html#conclusion",
    "title": "Markdown",
    "section": "Conclusion",
    "text": "Conclusion\nMarkdown is a powerful and versatile tool for writing clear, readable, and well-structured documents. Its simple syntax makes it easy to learn and use, while its flexibility allows you to create a wide variety of content. By mastering the basics of Markdown, you can significantly improve your writing workflow and create professional-looking documents with ease.",
    "crumbs": [
      "Coding Standards",
      "Documentation",
      "Markdown"
    ]
  },
  {
    "objectID": "documentation/docstrings.html",
    "href": "documentation/docstrings.html",
    "title": "Docstrings",
    "section": "",
    "text": "Well-documented code is crucial for maintainability, collaboration, and usability. NumPy style docstrings offer a standardized and readable format for documenting Python functions and classes, making your code easier to understand and use. This article provides a detailed guide on how to effectively document your Python code using this style.",
    "crumbs": [
      "Coding Standards",
      "Documentation",
      "Docstrings"
    ]
  },
  {
    "objectID": "documentation/docstrings.html#documenting-python-functions-and-classes-with-docstrings",
    "href": "documentation/docstrings.html#documenting-python-functions-and-classes-with-docstrings",
    "title": "Docstrings",
    "section": "",
    "text": "Well-documented code is crucial for maintainability, collaboration, and usability. NumPy style docstrings offer a standardized and readable format for documenting Python functions and classes, making your code easier to understand and use. This article provides a detailed guide on how to effectively document your Python code using this style.",
    "crumbs": [
      "Coding Standards",
      "Documentation",
      "Docstrings"
    ]
  },
  {
    "objectID": "documentation/docstrings.html#what-are-docstrings",
    "href": "documentation/docstrings.html#what-are-docstrings",
    "title": "Docstrings",
    "section": "What are Docstrings?",
    "text": "What are Docstrings?\nNumPy style docstrings are a convention for writing documentation within Python code, popularized by the NumPy and SciPy projects. They provide a structured format that clearly outlines the purpose, parameters, return values, and other essential details of functions and classes.",
    "crumbs": [
      "Coding Standards",
      "Documentation",
      "Docstrings"
    ]
  },
  {
    "objectID": "documentation/docstrings.html#structure-of-a-numpy-style-docstring",
    "href": "documentation/docstrings.html#structure-of-a-numpy-style-docstring",
    "title": "Docstrings",
    "section": "Structure of a NumPy Style Docstring:",
    "text": "Structure of a NumPy Style Docstring:\nA NumPy style docstring is a multi-line string enclosed in triple quotes (\"\"\"Docstring goes here\"\"\"). It typically follows this structure:\n\nShort Summary: A concise one-line description of the object.\nExtended Summary (Optional): A more detailed explanation of the object’s purpose and functionality.\nParameters: Describes the function’s parameters, including their names, types, and descriptions.\nReturns: Describes the value returned by the function, including its type and a description.\nYields (for Generators): Describes the values yielded by a generator function.\nRaises: Lists any exceptions that the function might raise.\nSee Also: Provides links to related functions, classes, or modules.\nNotes (Optional): Contains additional information or caveats about the object.\nReferences (Optional): Lists any relevant references or publications.\nExamples: Demonstrates how to use the object with executable code examples (doctests).",
    "crumbs": [
      "Coding Standards",
      "Documentation",
      "Docstrings"
    ]
  },
  {
    "objectID": "documentation/docstrings.html#documenting-functions",
    "href": "documentation/docstrings.html#documenting-functions",
    "title": "Docstrings",
    "section": "Documenting Functions:",
    "text": "Documenting Functions:\nHere’s an example of a function documented using NumPy style:\nimport numpy as np\n\ndef calculate_area(length, width):\n    \"\"\"\n    Calculates the area of a rectangle.\n\n    Parameters\n    ----------\n    length : float or int\n        The length of the rectangle.\n    width : float or int\n        The width of the rectangle.\n\n    Returns\n    -------\n    float\n        The area of the rectangle.\n\n    Raises\n    ------\n    TypeError\n        If either `length` or `width` is not a number.\n    ValueError\n        If either `length` or `width` is negative.\n\n    See Also\n    --------\n    calculate_perimeter : Calculates the perimeter of a rectangle.\n\n    Examples\n    --------\n    &gt;&gt;&gt; calculate_area(5, 10)\n    50.0\n    &gt;&gt;&gt; calculate_area(3.5, 7)\n    24.5\n    \"\"\"\n    if not isinstance(length, (int, float)) or not isinstance(width, (int, float)):\n        raise TypeError(\"Length and width must be numbers.\")\n    if length &lt; 0 or width &lt; 0:\n        raise ValueError(\"Length and width must be non-negative.\")\n    return float(length * width)\n\nKey elements explained:\n\nParameters: The Parameters section clearly lists each parameter with its type and a brief description.\nReturns: The Returns section specifies the type and a description of the returned value.\nRaises: The Raises section documents potential exceptions and the conditions under which they are raised.\nSee Also: The See Also section provides cross-references to related functions.\nExamples: The Examples section demonstrates how to use the function with doctests, which are executable code examples.",
    "crumbs": [
      "Coding Standards",
      "Documentation",
      "Docstrings"
    ]
  },
  {
    "objectID": "documentation/docstrings.html#documenting-classes",
    "href": "documentation/docstrings.html#documenting-classes",
    "title": "Docstrings",
    "section": "Documenting Classes:",
    "text": "Documenting Classes:\nHere’s an example of a class documented using NumPy style:\nclass Rectangle:\n    \"\"\"\n    Represents a rectangle.\n\n    Attributes\n    ----------\n    length : float or int\n        The length of the rectangle.\n    width : float or int\n        The width of the rectangle.\n\n    Methods\n    -------\n    area()\n        Calculates the area of the rectangle.\n    perimeter()\n        Calculates the perimeter of the rectangle.\n\n    Examples\n    --------\n    &gt;&gt;&gt; rect = Rectangle(5, 10)\n    &gt;&gt;&gt; rect.area()\n    50.0\n    &gt;&gt;&gt; rect.perimeter()\n    30.0\n    \"\"\"\n\n    def __init__(self, length, width):\n        \"\"\"\n        Initializes a Rectangle object.\n\n        Parameters\n        ----------\n        length : float or int\n            The length of the rectangle.\n        width : float or int\n            The width of the rectangle.\n        \"\"\"\n        self.length = length\n        self.width = width\n\n    def area(self):\n        \"\"\"\n        Calculates the area of the rectangle.\n\n        Returns\n        -------\n        float\n            The area of the rectangle.\n        \"\"\"\n        return float(self.length * self.width)\n\n    def perimeter(self):\n        \"\"\"\n        Calculates the perimeter of the rectangle.\n\n        Returns\n        -------\n        float\n            The perimeter of the rectangle.\n        \"\"\"\n        return float(2 * (self.length + self.width))\n\nKey elements explained:\n\nAttributes: The Attributes section lists the class’s attributes with their types and descriptions.\nMethods: The Methods section lists the class’s methods with brief descriptions.\nMethod Docstrings: Each method also has its own docstring, following the same NumPy style conventions as functions.",
    "crumbs": [
      "Coding Standards",
      "Documentation",
      "Docstrings"
    ]
  },
  {
    "objectID": "coding-standards/recommended-software.html",
    "href": "coding-standards/recommended-software.html",
    "title": "Recommended Software",
    "section": "",
    "text": "For Python development we recommend using Visual Studio Code. It has great support for Python and a large number of extensions for improving common tasks.\n\n\n\nPython: Provides Python language support and debugging capabilities.\nRuff: Provides linting and code formatting for Python.\nPyright: Provides static type checking for Python.\nGitLens: Provides user-friendly Git enhancements.\nGitHub Copilot: Provides AI-powered code suggestions.\nShiny: Run and develop Shiny apps in Python or R.\nQuarto: Extension for the Quarto scientific and technical publishing system.\nPosit Publisher: Publish and share your Python and R content on Posit Connect.\n\n\n\n\nTo take the most advantage of the extensions, we recommend the following settings. You can access these using CTRL + Shift + P and the type “settings”, then select Preferences: Open User Settings (JSON).\n{\n    \"[python]\": {\n        \"editor.defaultFormatter\": \"charliermarsh.ruff\",\n        \"editor.formatOnSave\": true,\n        \"editor.codeActionsOnSave\": {\n            \"source.fixAll\": \"explicit\",\n            \"source.organizeImports\": \"explicit\"\n        }\n    },\n    \"editor.rulers\": [90],\n    \"notebook.formatOnSave.enabled\": true,\n    \"notebook.codeActionsOnSave\": {\n        \"notebook.source.fixAll\": \"explicit\",\n        \"notebook.source.organizeImports\": \"explicit\"\n    },\n    \"files.autoSave\": \"afterDelay\",\n    \"files.trimTrailingWhitespace\": true,\n    \"github.copilot.enable\": {\n        \"quarto\": true,\n        \"*\": true\n    }\n}"
  },
  {
    "objectID": "coding-standards/recommended-software.html#integrated-development-environment",
    "href": "coding-standards/recommended-software.html#integrated-development-environment",
    "title": "Recommended Software",
    "section": "",
    "text": "For Python development we recommend using Visual Studio Code. It has great support for Python and a large number of extensions for improving common tasks.\n\n\n\nPython: Provides Python language support and debugging capabilities.\nRuff: Provides linting and code formatting for Python.\nPyright: Provides static type checking for Python.\nGitLens: Provides user-friendly Git enhancements.\nGitHub Copilot: Provides AI-powered code suggestions.\nShiny: Run and develop Shiny apps in Python or R.\nQuarto: Extension for the Quarto scientific and technical publishing system.\nPosit Publisher: Publish and share your Python and R content on Posit Connect.\n\n\n\n\nTo take the most advantage of the extensions, we recommend the following settings. You can access these using CTRL + Shift + P and the type “settings”, then select Preferences: Open User Settings (JSON).\n{\n    \"[python]\": {\n        \"editor.defaultFormatter\": \"charliermarsh.ruff\",\n        \"editor.formatOnSave\": true,\n        \"editor.codeActionsOnSave\": {\n            \"source.fixAll\": \"explicit\",\n            \"source.organizeImports\": \"explicit\"\n        }\n    },\n    \"editor.rulers\": [90],\n    \"notebook.formatOnSave.enabled\": true,\n    \"notebook.codeActionsOnSave\": {\n        \"notebook.source.fixAll\": \"explicit\",\n        \"notebook.source.organizeImports\": \"explicit\"\n    },\n    \"files.autoSave\": \"afterDelay\",\n    \"files.trimTrailingWhitespace\": true,\n    \"github.copilot.enable\": {\n        \"quarto\": true,\n        \"*\": true\n    }\n}"
  },
  {
    "objectID": "coding-standards/project-structure.html",
    "href": "coding-standards/project-structure.html",
    "title": "Project Structure",
    "section": "",
    "text": "Project structure in Python depends on whether you are creating an application or a package. The project manager app uv simplifies the process of creating a project structure. For critical processes, it is important that the code is structured in an organised and consistent manner. For example, Python code should be broken up into functions or classes with methods and stored in a folder of modules. Each file should have a test script, testing the functions and methods it contains in the tests folder.",
    "crumbs": [
      "Coding Standards",
      "Project Structure"
    ]
  },
  {
    "objectID": "coding-standards/project-structure.html#application-structure",
    "href": "coding-standards/project-structure.html#application-structure",
    "title": "Project Structure",
    "section": "Application Structure",
    "text": "Application Structure\nAn application is a standalone program that is run from the command line or a GUI. The structure of an application is similar to a package, but with a few differences. The main difference is that an application has a run script that is used to start the application. The run script is the entry point to the application and is used to load the modules and call the functions.\nTo create an application structure, use uv within PowerShell:\nuv init example-app\nThis creates a folder called example-app with the following structure:\ntree example-app\nexample-app\n├── .python_version\n├── README.md\n├── hello.py\n└── pyproject.toml\nThe .python_version file specifies the version of Python to use. The README.md file should be used to document the application. The hello.py file is the main module of the application. If you are buiding a Shiny app, you would replace or rename this app.py. The pyproject.toml file is used to specify the metadata for the application.\n\n\n\n\n\n\nNote\n\n\n\nuv determines the version of Python to use based on installed versions. If you have more than one Python installation, it is a good idea to specify the version to use when creating the project. For example:\nuv init example-app --python 3.12\n\n\nThe pyproject.toml file contains the metadata below, you should update the description.\n[project]\nname = \"example-app\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nreadme = \"README.md\"\nrequires-python = \"&gt;=3.11\"\ndependencies = []\nWhen adding code to the appication, there should be a simple top-level scripts for running the processes or application. These should not contain any logic, instead they should import functions from modules stored in folders and call them in order. Parameters or constants should be cearly defined at the top of these scripts.\nTo define modules, create a suitably named folder and .py file within. Define any functions, classes and methods, within that file. In order to import, the function you must also create a init.py file within the folder. The init.py does not need to contain anything, but if you want to limit the functions, classes and methods available outside the module, you can specify them here. For example, if your project structure looks like:\nexample-app\n├── .python_version\n├── README.md\n├── main.py\n├── pyproject.toml\n└── some_module\n    ├── __init__.py\n    └── some_file\nThen you can specify the functions and classes to make available in the __init_.py using:\nsome_module/__init__.py\nfrom .some_file import some_function\nfrom .some_file import SomeClass\nThen you can import them in your main.py script using:\nmain.py\nimport some_module\n\nsome_module.some_function()\nsome_module.SomeClass()\nFor Shiny applications, we use the the project structure defined by Tapyr.",
    "crumbs": [
      "Coding Standards",
      "Project Structure"
    ]
  },
  {
    "objectID": "coding-standards/project-structure.html#library-structure",
    "href": "coding-standards/project-structure.html#library-structure",
    "title": "Project Structure",
    "section": "Library Structure",
    "text": "Library Structure\nA library provides functions and objects for other projects to consume. Libraries are intended to be built and distributed, e.g., by uploading them to Package Manager.\nLibraries can be created by using the –lib flag:\nuv init --lib example-lib\nA src layout is used to ensure that the library is isolated from any python invocations in the project root and that distributed library code is well separated from the rest of the project source.\ntree example-lib\nexample-lib\n├── .python_version\n├── README.md\n├── pyproject.toml\n└── src\n    └── example_lib\n        ├── py.typed\n        └── __init__.py\nFor more details on building packages, see building packages",
    "crumbs": [
      "Coding Standards",
      "Project Structure"
    ]
  },
  {
    "objectID": "coding-standards/factoring.html",
    "href": "coding-standards/factoring.html",
    "title": "Factoring",
    "section": "",
    "text": "In software development, writing code is just the first step. As projects evolve, maintaining clean, efficient, and readable code becomes crucial. This is where factoring and refactoring come into play, especially in a versatile language like Python.",
    "crumbs": [
      "Coding Standards",
      "Factoring"
    ]
  },
  {
    "objectID": "coding-standards/factoring.html#the-importance-of-factoring-and-refactoring-in-python",
    "href": "coding-standards/factoring.html#the-importance-of-factoring-and-refactoring-in-python",
    "title": "Factoring",
    "section": "",
    "text": "In software development, writing code is just the first step. As projects evolve, maintaining clean, efficient, and readable code becomes crucial. This is where factoring and refactoring come into play, especially in a versatile language like Python.",
    "crumbs": [
      "Coding Standards",
      "Factoring"
    ]
  },
  {
    "objectID": "coding-standards/factoring.html#factoring-decomposing-complexity",
    "href": "coding-standards/factoring.html#factoring-decomposing-complexity",
    "title": "Factoring",
    "section": "Factoring: Decomposing Complexity",
    "text": "Factoring: Decomposing Complexity\nFactoring, in the context of programming, is the process of breaking down a complex problem or piece of code into smaller, more manageable parts. This involves identifying common patterns, extracting reusable components, and creating modular structures. In Python, this can be achieved through:\n\nFunctions: Encapsulating specific tasks into functions promotes code reuse and improves readability.\nClasses: Object-oriented programming allows grouping related data and functions into classes, creating well-defined entities.\nModules and Packages: Arranging code into modules and packages enables better code organization and namespace management.\n\nBy factoring code effectively, developers can:\n\nReduce Complexity: Smaller, focused components are easier to understand and maintain.\nIncrease Reusability: Factored code can be reused across different parts of the project or even in other projects.\nImprove Testability: Smaller units of code are easier to test in isolation.",
    "crumbs": [
      "Coding Standards",
      "Factoring"
    ]
  },
  {
    "objectID": "coding-standards/factoring.html#refactoring-improving-existing-code",
    "href": "coding-standards/factoring.html#refactoring-improving-existing-code",
    "title": "Factoring",
    "section": "Refactoring: Improving Existing Code",
    "text": "Refactoring: Improving Existing Code\nRefactoring, on the other hand, focuses on improving the internal structure of existing code without changing its external behavior. It’s about cleaning up the code, making it more readable, efficient, and maintainable. Common refactoring techniques in Python include:\n\nRenaming variables and functions: Choosing descriptive names enhances code clarity.\nSimplifying complex expressions: Breaking down complex logic into smaller, more understandable steps.\nRemoving duplicate code: Identifying and extracting common code blocks into reusable functions or classes.\nImproving code structure: Reorganizing code to improve its flow and readability.\n\nThe benefits of refactoring are numerous:\n\nEnhanced Readability: Clean, well-structured code is easier to understand and maintain.\nReduced Technical Debt: Addressing code issues early on prevents them from accumulating and causing problems later.\nImproved Performance: Refactoring can sometimes lead to performance improvements by optimizing algorithms or data structures.\nEasier Collaboration: Well-structured code facilitates collaboration among developers.",
    "crumbs": [
      "Coding Standards",
      "Factoring"
    ]
  },
  {
    "objectID": "coding-standards/factoring.html#factoring-and-refactoring-in-practice",
    "href": "coding-standards/factoring.html#factoring-and-refactoring-in-practice",
    "title": "Factoring",
    "section": "Factoring and Refactoring in Practice",
    "text": "Factoring and Refactoring in Practice\nBoth factoring and refactoring are essential practices for writing maintainable and scalable Python code. They should be integrated into the development process from the beginning, rather than being treated as afterthoughts.\n\nPlan for Factoring: When starting a new project or feature, consider how to break down the problem into smaller, manageable parts.\nRefactor Regularly: Don’t wait for code to become a mess before refactoring. Regularly review and improve your code to keep it clean and maintainable.\nUse Tools: Several tools can assist with refactoring in Python, such as Ruff in Visual Studio Code.\n\nWhen deciding how to divide up code a useful rule-of-thumb is to describe what the code is doing as bullet points. Each bullet point could then be a function or method. If a function/method is still complex you may want to divide it further in to smaller functions. Keep going until each function is doing one thing, and one thing only.\nAnother rule-of-thumb is if you find yourself repeating a chunk of code more than twice, then make it a function, and call it instead. This means any future changes can be made in one place, rather than many.\nBy embracing factoring and refactoring, Python developers can write code that is not only functional but also clean, efficient, and easy to maintain, ensuring the long-term success of their projects.",
    "crumbs": [
      "Coding Standards",
      "Factoring"
    ]
  },
  {
    "objectID": "coding-standards/coding-style.html",
    "href": "coding-standards/coding-style.html",
    "title": "Coding Style",
    "section": "",
    "text": "The official Python style guide is known as PEP 8. In Lloyd’s, code should follow the PEP 8 style, as described. For a more accessible overview, read the article How to Write Beautiful Python Code With PEP 8.\n\n\nTo simplify the process of adhering to the PEP 8 conventions, we recomend using Ruff to style your code. Ruff checks your code and gives guidance on how to fix any issues (also known as linting). It can be run from the command line or as a Visual Studio Code extension. The extension can also be used to format your code and it is recommended to set the option to format on save, to keep your code tidy. This can be achieved by adding the following options to your settings.json file:\n\"[python]\": {\n    \"editor.defaultFormatter\": \"charliermarsh.ruff\",\n    \"editor.formatOnSave\": true,\n    \"editor.codeActionsOnSave\": {\n        \"source.fixAll\": \"explicit\",\n        \"source.organizeImports\": \"explicit\"\n    }\n}",
    "crumbs": [
      "Coding Standards",
      "Coding Style"
    ]
  },
  {
    "objectID": "coding-standards/coding-style.html#style-guide",
    "href": "coding-standards/coding-style.html#style-guide",
    "title": "Coding Style",
    "section": "",
    "text": "The official Python style guide is known as PEP 8. In Lloyd’s, code should follow the PEP 8 style, as described. For a more accessible overview, read the article How to Write Beautiful Python Code With PEP 8.\n\n\nTo simplify the process of adhering to the PEP 8 conventions, we recomend using Ruff to style your code. Ruff checks your code and gives guidance on how to fix any issues (also known as linting). It can be run from the command line or as a Visual Studio Code extension. The extension can also be used to format your code and it is recommended to set the option to format on save, to keep your code tidy. This can be achieved by adding the following options to your settings.json file:\n\"[python]\": {\n    \"editor.defaultFormatter\": \"charliermarsh.ruff\",\n    \"editor.formatOnSave\": true,\n    \"editor.codeActionsOnSave\": {\n        \"source.fixAll\": \"explicit\",\n        \"source.organizeImports\": \"explicit\"\n    }\n}",
    "crumbs": [
      "Coding Standards",
      "Coding Style"
    ]
  },
  {
    "objectID": "coding-standards/coding-style.html#naming-conventions",
    "href": "coding-standards/coding-style.html#naming-conventions",
    "title": "Coding Style",
    "section": "Naming Conventions",
    "text": "Naming Conventions\nTo ensure that code is written consistenty across projects, use the following naming conventions.\n\n\n\n\n\n\n\n\nType\nNaming Convention\nExamples\n\n\n\n\nVariable\nUse a lowercase single letter, word, or words. Separate words with underscores to improve readability.\nx, var, python_variable\n\n\nFunction\nUse a lowercase word or words. Separate words by underscores to improve readability.\nfunction, python_function\n\n\nClass\nStart each word with a capital letter. Don’t separate words with underscores. This style is called camel case or Pascal case.\nModel, PythonClass\n\n\nMethod\nUse a lowercase word or words. Separate words with underscores to improve readability.\nclass_method, method\n\n\nConstant\nUse an uppercase single letter, word, or words. Separate words with underscores to improve readability.\nCONSTANT, PYTHON_CONSTANT, PYTHON_LONG_CONSTANT\n\n\nModule\nUse a short, lowercase word or words. Separate words with underscores to improve readability.\nmodule.py, python_module.py\n\n\nPackage\nUse a short, lowercase word or words. Don’t separate words with underscores.\npackage, pythonpackage\n\n\n\n\nUse Meaningful Names\nDon’t use vague or one-letter names (like x or y) if it is not for simple and short loops. Instead, give names that explain what the variable or the function does. This makes code much easier to read and understand.\nBad Example:\ndef a(x, y):\n    return x + y\nGood Example:\ndef add_numbers(first_number, second_number):\n    return first_number + second_number",
    "crumbs": [
      "Coding Standards",
      "Coding Style"
    ]
  },
  {
    "objectID": "coding-standards/coding-style.html#code-layout",
    "href": "coding-standards/coding-style.html#code-layout",
    "title": "Coding Style",
    "section": "Code Layout",
    "text": "Code Layout\n\nBlank Lines\n\nSurround top-level functions and classes with two blank lines.\nSurround method definitions inside classes with a single blank line.\nUse blank lines sparingly inside functions to show clear steps.\n\ndef add(a, b):\n    return a + b\n\n\ndef subtract(a, b):\n    return a - b\n\n\nIndentation\n\nUse four spaces to indent code.\n\ndef greet():\n    print(\"Hello!\")\n\nFor long lines, we recommend using a hanging indent and put closing brackets on a new line, for example:\n\ndef function(\n    arg_one,\n    arg_two,\n    arg_three,\n    arg_four\n):\n    list_of_numbers = [\n        arg_one,\n        arg_two,\n        arg_three,\n        arg_four\n    ]\n\n    return list_of_numbers\n\n\nLine Length\n\nLimit line length to 80 characters: Keep your code readable by not writing overly long lines. If a line gets too long, break it into smaller parts using parentheses or backslashes.\n\n\n\nComments\n\nComments should be used sparingly. Using good names and clear layout should be enough in most cases. Comments should focus on why the code is written in a certain way, not what the code does.\nFor complicated code, split it into functions, classes and methods and use docstrings to document them instead.\n\n\n\nWhitespace\n\nSurround binary operators with a space.\nAdd a space after a comma\nDo not use spaces around = when assigning function and method arguments\nDo not leave spaces at the end of the line. Visual Studio Code has an option to remove trailing whitespace on save:\n\n\"files.trimTrailingWhitespace\": true,",
    "crumbs": [
      "Coding Standards",
      "Coding Style"
    ]
  },
  {
    "objectID": "coding-standards/coding-style.html#coding-practices",
    "href": "coding-standards/coding-style.html#coding-practices",
    "title": "Coding Style",
    "section": "Coding Practices",
    "text": "Coding Practices\n\nAvoid Hardcoding Values\nHardcoding values (e.g., numbers or strings) directly into your code can make it difficult to update or reuse. Instead, use variables or constants.\nBad Example:\nprint(\"The total price with tax is: $105\")  # Hardcoded tax and total price\nGood Example:\nPRICE = 100  # Base price of the product\nTAX_RATE = 0.05  # 5% tax rate\n\n# Calculate the total price\ntotal_price = PRICE + (PRICE * TAX_RATE)\n\nprint(f\"The total price with tax is: ${total_price:.2f}\")\nThis makes your code more flexible and easy to modify.\n\n\nAvoid Global Variables\nRelying on global variables can make your code harder to understand and debug. Instead, encapsulate state within classes or functions.\nBad Example (using a global variable):\ntotal = 0\n\ndef add_to_total(value):\n    global total\n    total += value\nGood Example (using a class):\nclass Calculator:\n    def __init__(self):\n        self.total = 0\n\n    def add_value(self, value):\n        self.total += value\nEncapsulating data within objects or functions ensures that your code is modular, testable, and less error-prone.\n\n\nUse f-Strings for String Formatting\nf-Strings (introduced in Python 3.6) are a clean and readable way to format strings.\nBad Example (concatenating strings):\nname = \"Alice\"\nage = 25\nprint(\"My name is \" + name + \" and I am \" + str(age) + \" years old\")\nGood Example (using f-strings):\nname = \"Alice\"\nage = 25\nprint(f\"My name is {name} and I am {age} years old\")\nf-Strings are not only more readable but also more efficient than other string formatting methods.\n\n\nUse Built-in Functions and Libraries\nPython comes with many powerful built-in features. Use these to write efficient and proper code instead of coding it from scratch.\nBad Example (manually finding the maximum):\ndef find_max(numbers):\n    max_number = numbers[0]\n    for num in numbers:\n        if num &gt; max_number:\n            max_number = num\n    return max_number\nGood Example (using max):\ndef find_max(numbers):\n    return max(numbers)\n\n\nUse Pythonic Code\n“Pythonic” code refers to writing code that takes advantage of Python’s simplicity and readability. Avoid overly complex or verbose solutions when simpler options are available.\nBad Example:\nnumbers = [1, 2, 3, 4, 5]\ndoubled = []\nfor num in numbers:\n    doubled.append(num * 2)\nGood Example:\nnumbers = [1, 2, 3, 4, 5]\ndoubled = [num * 2 for num in numbers]\nUsing list comprehensions, built-in functions, and readable idioms makes your code more elegant.\n\n\nHandle Errors Gracefully\nAs a beginner, it’s tempting to skip error handling, but it’s an important part of writing good code. Use try and except blocks to handle potential errors.\ntry:\n    number = int(input(\"Enter a number: \"))\n    print(f\"The number is {number}\")\nexcept ValueError:\n    print(\"That’s not a valid number!\")\nThis ensures your program doesn’t crash unexpectedly.",
    "crumbs": [
      "Coding Standards",
      "Coding Style"
    ]
  },
  {
    "objectID": "coding-standards/design-patterns.html",
    "href": "coding-standards/design-patterns.html",
    "title": "Design Patterns",
    "section": "",
    "text": "In software development, writing functional code is just the beginning. As projects grow in complexity, maintaining, scaling, and collaborating on the codebase becomes significantly more challenging. This is where design patterns come into play. Design patterns are reusable solutions to recurring problems in software design, offering proven templates for structuring code and addressing common challenges. This article explores the importance of design patterns in Python development.",
    "crumbs": [
      "Coding Standards",
      "Design Patterns"
    ]
  },
  {
    "objectID": "coding-standards/design-patterns.html#the-importance-of-design-patterns-in-python",
    "href": "coding-standards/design-patterns.html#the-importance-of-design-patterns-in-python",
    "title": "Design Patterns",
    "section": "",
    "text": "In software development, writing functional code is just the beginning. As projects grow in complexity, maintaining, scaling, and collaborating on the codebase becomes significantly more challenging. This is where design patterns come into play. Design patterns are reusable solutions to recurring problems in software design, offering proven templates for structuring code and addressing common challenges. This article explores the importance of design patterns in Python development.",
    "crumbs": [
      "Coding Standards",
      "Design Patterns"
    ]
  },
  {
    "objectID": "coding-standards/design-patterns.html#what-are-design-patterns",
    "href": "coding-standards/design-patterns.html#what-are-design-patterns",
    "title": "Design Patterns",
    "section": "What are Design Patterns?",
    "text": "What are Design Patterns?\nDesign patterns are not ready-made code that you can copy and paste. Instead, they are conceptual solutions to common design problems. They describe a general approach to structuring code, defining the relationships between classes and objects, and outlining how they interact. They offer a common vocabulary for developers to communicate design choices and facilitate collaboration.",
    "crumbs": [
      "Coding Standards",
      "Design Patterns"
    ]
  },
  {
    "objectID": "coding-standards/design-patterns.html#why-are-design-patterns-important-in-python",
    "href": "coding-standards/design-patterns.html#why-are-design-patterns-important-in-python",
    "title": "Design Patterns",
    "section": "Why are Design Patterns Important in Python?",
    "text": "Why are Design Patterns Important in Python?\nPython, with its dynamic typing and multiple programming paradigms (object-oriented, functional, etc.), offers flexibility in how you structure your code. However, this flexibility can also lead to inconsistencies and complexities if not managed properly. Design patterns provide a framework for managing this complexity and offer several key benefits:\n\nImproved Code Reusability: Design patterns offer proven solutions that can be adapted and reused across different projects or within the same project. This reduces development time and effort by avoiding reinventing the wheel.\nEnhanced Code Maintainability: Well-structured code based on established patterns is easier to understand, modify, and debug. This reduces the cost of maintaining and evolving the software over time.\nIncreased Code Readability: Design patterns provide a common vocabulary for developers. When a developer recognizes a pattern in the code, they immediately understand the underlying structure and intent, making the code more readable and easier to grasp.\nBetter Communication and Collaboration: Design patterns provide a shared language for developers to discuss design choices. This improves communication and collaboration within development teams, leading to more efficient and effective teamwork.\nProven Solutions to Common Problems: Design patterns represent best practices and proven solutions to recurring design problems. By using design patterns, developers can avoid common pitfalls and create more robust and reliable software.\nAbstraction and Encapsulation: Many design patterns promote abstraction and encapsulation, which are fundamental principles of good software design. These principles help to reduce dependencies between different parts of the code, making it more modular and easier to change.\nScalability and Flexibility: Design patterns can help to create more scalable and flexible software systems. By using patterns that promote loose coupling and modularity, developers can more easily adapt their software to changing requirements and increasing demands.",
    "crumbs": [
      "Coding Standards",
      "Design Patterns"
    ]
  },
  {
    "objectID": "coding-standards/design-patterns.html#common-categories-of-design-patterns",
    "href": "coding-standards/design-patterns.html#common-categories-of-design-patterns",
    "title": "Design Patterns",
    "section": "Common Categories of Design Patterns:",
    "text": "Common Categories of Design Patterns:\nDesign patterns are typically categorized into three main types:\n\nCreational Patterns: These patterns deal with object creation mechanisms, providing ways to create objects in a flexible and controlled manner. Examples include Singleton, Factory Method, and Abstract Factory.\nStructural Patterns: These patterns deal with the composition of classes and objects to form larger structures. Examples include Adapter, Decorator, and Facade.\nBehavioral Patterns: These patterns deal with the assignment of responsibilities between objects and how they communicate with each other. Examples include Observer, Strategy, and Template Method.",
    "crumbs": [
      "Coding Standards",
      "Design Patterns"
    ]
  },
  {
    "objectID": "coding-standards/design-patterns.html#using-design-patterns-effectively-in-python",
    "href": "coding-standards/design-patterns.html#using-design-patterns-effectively-in-python",
    "title": "Design Patterns",
    "section": "Using Design Patterns Effectively in Python:",
    "text": "Using Design Patterns Effectively in Python:\nIt’s important to remember that design patterns are not a silver bullet. Applying them blindly without understanding the context can lead to over-engineering and unnecessary complexity. Here are some guidelines for using design patterns effectively in Python:\n\nUnderstand the Problem First: Don’t try to force-fit a design pattern into a situation where it’s not needed. Clearly understand the problem you’re trying to solve before choosing a pattern.\nChoose the Right Pattern: Select the pattern that best addresses the specific problem at hand. Consider the trade-offs of each pattern and choose the one that best fits the context.\nDon’t Overuse Patterns: Using too many patterns can make the code overly complex and difficult to understand. Use patterns judiciously and only when they provide a clear benefit.\nAdapt Patterns to Python: Python’s dynamic nature and features like decorators and metaclasses can offer elegant ways to implement design patterns. Adapt the patterns to take advantage of these features.\n\nBy understanding and applying design patterns effectively, Python developers can write cleaner, more maintainable, and more scalable code, ultimately leading to more successful software projects.",
    "crumbs": [
      "Coding Standards",
      "Design Patterns"
    ]
  },
  {
    "objectID": "coding-standards/design-patterns.html#formalising-patterns-in-a-package",
    "href": "coding-standards/design-patterns.html#formalising-patterns-in-a-package",
    "title": "Design Patterns",
    "section": "Formalising Patterns in a Package",
    "text": "Formalising Patterns in a Package\nOne way to ensure patterns are followed is to capture the approach in a package. A package is the best way to share code across multiple projects. For example, if you have a common way to read data from a shared database, you could create a function or functions and add them to an internal package. This way, the approach is documented and can be easily shared across projects.\nAnother way to ensure patterns are followed is to create a template project. A template project is a project that contains the structure and code that all projects should follow. When a new project is started, the template project is copied and modified to suit the new project. This ensures that all projects follow the same structure and code patterns.\nExamples of existing patterns we use include:\n\nlloydsdb: lloydsdb is a package that provides a common way to read and write data from a Lloyd’s database. It also contains a general approach for running processes and capturing outputs and an audit trail.\nlloydsbrand: lloydsbrand is a package that provides styling and formatting option for applications and reports, so they follow Lloyd’s brand guidelines.\nTapyr: Tapyr provides a template for Shiny applications.",
    "crumbs": [
      "Coding Standards",
      "Design Patterns"
    ]
  },
  {
    "objectID": "coding-standards/index.html",
    "href": "coding-standards/index.html",
    "title": "Coding Standards",
    "section": "",
    "text": "When writing code in any language it is important to follow coding standards. They make it easier to read and understand the code. New starters will be able to learn how projects work faster, which reduces key-person dependencies.\nPython has some standard approaches to building projects, which then give you access to useful tools to aid in development, so they should be used wherever possible. Python has a very large number of packages, and sometimes more than one for the same job. Having a set of recommended packages ensures consistency across projects. When common patterns are identified across projects, they should be extracted into packages themselves so they can be shared easily.\nEach section details the minimum standards, based on the criticality of the project. The standards are cumulative, so medium criticality must meet both medium and low standards.",
    "crumbs": [
      "Coding Standards"
    ]
  },
  {
    "objectID": "coding-standards/index.html#low-criticality",
    "href": "coding-standards/index.html#low-criticality",
    "title": "Coding Standards",
    "section": "Low Criticality",
    "text": "Low Criticality\n\n\n\n\n\n\n\n\nCoding Style\n\n\n\nStyling your code in a consistent way makes it easier to read and understand. Having agreed conventions makes it easier to locate and maintain code. Writing code well is about helping future developers.\n\n\n\n\n\n\n\n\n\n\nRecommended Packages\n\n\n\nSpecifying recommended packages ensures the same approach is taken across projects. If all the team use the same packages, then it is much easier for members to work across projects.",
    "crumbs": [
      "Coding Standards"
    ]
  },
  {
    "objectID": "coding-standards/index.html#medium-criticality",
    "href": "coding-standards/index.html#medium-criticality",
    "title": "Coding Standards",
    "section": "Medium Criticality",
    "text": "Medium Criticality\n\n\n\n\n\n\n\n\nFactoring\n\n\n\nAs code gets more complicated a large script becomes harder to understand and maintain. Variables defined at the top of the scripts may be used much later, so when making changes it becomes difficult to understand the consequences. In this case it is time to split the code up into smaller pieces, also known as factoring.\n\n\n\n\n\n\n\n\n\n\nRecommended Software\n\n\n\nTo ensure a consistent across developers it is a good idea to define recommended software. This includes the IDE to use and any supporting software, such as version control, AI, etc. If everyone uses the same approach it is easier to support new joiners and each other.",
    "crumbs": [
      "Coding Standards"
    ]
  },
  {
    "objectID": "coding-standards/index.html#high-criticality",
    "href": "coding-standards/index.html#high-criticality",
    "title": "Coding Standards",
    "section": "High Criticality",
    "text": "High Criticality\n\n\n\n\n\n\n\n\nProject Structure\n\n\n\nFor critical processes it is important the code is structured in an organised and consistent manner. For example, Python code should be broken up into functions or classes with methods and stored in a folder of modules. Each file should have a test script, testing the functions and methods it contains in the tests folder.\n\n\n\n\n\n\n\n\n\n\nDesign Patterns\n\n\n\nWhen you work on many projects, you start to see repeated patterns emerging. This generally starts as similar snippets of code or copying code from one project to another. It is worth specifying the approach all projects should take. Even better, the approach can be captured in a function or functions and added to an internal package.",
    "crumbs": [
      "Coding Standards"
    ]
  },
  {
    "objectID": "coding-standards/recommended-packages.html",
    "href": "coding-standards/recommended-packages.html",
    "title": "Recommended Packages",
    "section": "",
    "text": "While Pandas is the most popular package for data wrangling in Python, and may be used, it is recommended to use Polars instead. Polars is more performant and has more readable syntax. It is built to chain methods in an elegant way, for example:\nimport polars as pl\n\ndf = (\n    pl.read_csv(\"docs/assets/data/iris.csv\")\n    .filter(pl.col(\"sepal_length\") &gt; 5)\n    .group_by(\"species\")\n    .agg(pl.all().sum())\n)",
    "crumbs": [
      "Coding Standards",
      "Recommended Packages"
    ]
  },
  {
    "objectID": "coding-standards/recommended-packages.html#data-wrangling",
    "href": "coding-standards/recommended-packages.html#data-wrangling",
    "title": "Recommended Packages",
    "section": "",
    "text": "While Pandas is the most popular package for data wrangling in Python, and may be used, it is recommended to use Polars instead. Polars is more performant and has more readable syntax. It is built to chain methods in an elegant way, for example:\nimport polars as pl\n\ndf = (\n    pl.read_csv(\"docs/assets/data/iris.csv\")\n    .filter(pl.col(\"sepal_length\") &gt; 5)\n    .group_by(\"species\")\n    .agg(pl.all().sum())\n)",
    "crumbs": [
      "Coding Standards",
      "Recommended Packages"
    ]
  },
  {
    "objectID": "coding-standards/recommended-packages.html#reading-and-writing-data",
    "href": "coding-standards/recommended-packages.html#reading-and-writing-data",
    "title": "Recommended Packages",
    "section": "Reading and Writing data",
    "text": "Reading and Writing data\nPolars has a number of methods for reading from and writing to common formats. Some of them depend on other packages:\n\nCSV\nPolars can read and write to CSV out of the box, using:\nimport polars as pl\n\ndf = pl.read_csv(\"data.csv\")\ndf.write_csv(\"data.csv\")\n\n\nExcel\nPolars can read data from Excel by installing the fastexcel package and write using the xlsxwriter package. Once installed, you can use:\ndf = pl.read_excel(\"data.xlsx\", sheet_name=\"Sheet1\")\ndf.write_excel(\"data.xlsx\", worksheet=\"Sheet2\")\n\n\nDatabases\nPolars can read and write to a database, if an appropriate connection is supplied. See lloydsdb for more details.\nimport polars as pl\nimport lloydsdb as db\n\nengine = db.create_engine(\"Reserving_data\")\ndf = pl.read_database(\"SELECT * FROM OldTable\", connection=engine)\ndf.write_database(\"NewTable\",  connection=engine)",
    "crumbs": [
      "Coding Standards",
      "Recommended Packages"
    ]
  },
  {
    "objectID": "coding-standards/recommended-packages.html#visualisation",
    "href": "coding-standards/recommended-packages.html#visualisation",
    "title": "Recommended Packages",
    "section": "Visualisation",
    "text": "Visualisation\nFor static charts it is recommended to use Seaborn. For example:\n\nimport seaborn as sns\n\ntips = sns.load_dataset(\"tips\")\nsns.relplot(data=tips, x=\"total_bill\", y=\"tip\")\n\n\n\n\n\n\n\n\nHowever, for interactive charts it is recommended to use Plotly instead. For example:\n\nimport plotly.express as px\n\ntips = px.data.tips()\npx.scatter(tips, x=\"total_bill\", y=\"tip\")",
    "crumbs": [
      "Coding Standards",
      "Recommended Packages"
    ]
  },
  {
    "objectID": "coding-standards/recommended-packages.html#reporting",
    "href": "coding-standards/recommended-packages.html#reporting",
    "title": "Recommended Packages",
    "section": "Reporting",
    "text": "Reporting\nWhen it comes to producing reports, Quarto provides a simple, versatile and beautiful approach. It can be used to produce:\n\nArticles\nPresentations\nBooks\nWebsites\nDashboards",
    "crumbs": [
      "Coding Standards",
      "Recommended Packages"
    ]
  },
  {
    "objectID": "coding-standards/recommended-packages.html#web-applications",
    "href": "coding-standards/recommended-packages.html#web-applications",
    "title": "Recommended Packages",
    "section": "Web Applications",
    "text": "Web Applications\nWhen building dashboards or web applications, it is recommended to use Shiny. Shiny provides a simple to use framework, allowing the developer to concentrate on the content and controls. For example, a basic app can be created using:\nfrom shiny import App, render, ui\n\napp_ui = ui.page_fixed(\n    ui.h1(\"Simple App\"),\n    ui.input_text(\"name\", \"Enter your name\"),\n    ui.output_text(\"greeting\"),\n)\n\n\ndef server(input, output, session):\n    @render.text\n    def greeting():\n        return f\"Hello {input.name()}, welcome to shiny!.\"\n\n\napp = App(app_ui, server)\nFor best practices when building Shiny web applications, see Shiny.",
    "crumbs": [
      "Coding Standards",
      "Recommended Packages"
    ]
  },
  {
    "objectID": "documentation/changelog.html",
    "href": "documentation/changelog.html",
    "title": "Change Log",
    "section": "",
    "text": "Changelogs are essential for any software project, but they’re often overlooked or poorly written. A well-maintained changelog provides valuable information to users, contributors, and maintainers. For Python projects, a clear and concise changelog can significantly improve communication and project transparency.",
    "crumbs": [
      "Coding Standards",
      "Documentation",
      "Change Log"
    ]
  },
  {
    "objectID": "documentation/changelog.html#writing-effective-changelogs",
    "href": "documentation/changelog.html#writing-effective-changelogs",
    "title": "Change Log",
    "section": "",
    "text": "Changelogs are essential for any software project, but they’re often overlooked or poorly written. A well-maintained changelog provides valuable information to users, contributors, and maintainers. For Python projects, a clear and concise changelog can significantly improve communication and project transparency.",
    "crumbs": [
      "Coding Standards",
      "Documentation",
      "Change Log"
    ]
  },
  {
    "objectID": "documentation/changelog.html#key-components",
    "href": "documentation/changelog.html#key-components",
    "title": "Change Log",
    "section": "Key Components",
    "text": "Key Components\n\nClear and Concise: Use short, descriptive sentences that are easy to understand. Avoid technical jargon whenever possible.\nMarkdown: Use Markdown to format the document and adhere to it throughout the project’s history. This makes it easier to read and navigate.\nVersion Numbers: Clearly indicate the version number for each set of changes (e.g., “v1.2.3”).\nTypes of Changes: Categorize changes using conventions:\n\nAdded: New functionality.\nUpdated: Existing functionality that has been changed.\nFixed: Bug fixes, security updates.\n\nDetailed Descriptions: Provide sufficient detail for each change. For example:\n\n“Added support for Python 3.11.”\n“Fixed a bug where the library would crash when processing large files.”\n“Improved performance by 20%.”",
    "crumbs": [
      "Coding Standards",
      "Documentation",
      "Change Log"
    ]
  },
  {
    "objectID": "documentation/changelog.html#example-changelog",
    "href": "documentation/changelog.html#example-changelog",
    "title": "Change Log",
    "section": "Example Changelog",
    "text": "Example Changelog\n## 1.2.0\n\n### Added\n* New feature: Support for asynchronous operations.\n* Improved documentation.\n\n### Updated\n* Updated dependency on `requests` to the latest version.\n\n### Fixed\n* Resolved a critical bug that caused the library to crash under certain conditions.",
    "crumbs": [
      "Coding Standards",
      "Documentation",
      "Change Log"
    ]
  },
  {
    "objectID": "documentation/changelog.html#best-practices",
    "href": "documentation/changelog.html#best-practices",
    "title": "Change Log",
    "section": "Best Practices",
    "text": "Best Practices\n\nStart Early: Begin maintaining a changelog from the very beginning of your project.\nKeep it Updated: Regularly update the changelog with each release.\nReview and Edit: Regularly review and edit the changelog to ensure clarity and accuracy.\nMake it Accessible: Make the changelog easily accessible to users (e.g., on the project’s website or in the documentation).",
    "crumbs": [
      "Coding Standards",
      "Documentation",
      "Change Log"
    ]
  },
  {
    "objectID": "documentation/changelog.html#conclusion",
    "href": "documentation/changelog.html#conclusion",
    "title": "Change Log",
    "section": "Conclusion",
    "text": "Conclusion\nBy following these guidelines, you can create effective changelogs for your Python projects. Well-maintained changelogs improve communication, build trust with users, and contribute to a more professional and maintainable project.",
    "crumbs": [
      "Coding Standards",
      "Documentation",
      "Change Log"
    ]
  },
  {
    "objectID": "documentation/index.html",
    "href": "documentation/index.html",
    "title": "Documentation",
    "section": "",
    "text": "Markdown\n\n\n\nMarkdown is a lightweight markup language with plain text formatting syntax. It’s designed to be easy to read and write, converting plain text into rich text formats like HTML. Its simplicity has made it popular for writing documentation and creating content for websites.\n\n\n\n\n\n\n\n\n\n\nREADME\n\n\n\nA README file is the first thing someone looking at your code reads. It should contain a summary of the project and instructions for how to use it. The README should be clear and concise, and link to further documentation if more detail is required.",
    "crumbs": [
      "Coding Standards",
      "Documentation"
    ]
  },
  {
    "objectID": "documentation/index.html#low-criticality",
    "href": "documentation/index.html#low-criticality",
    "title": "Documentation",
    "section": "",
    "text": "Markdown\n\n\n\nMarkdown is a lightweight markup language with plain text formatting syntax. It’s designed to be easy to read and write, converting plain text into rich text formats like HTML. Its simplicity has made it popular for writing documentation and creating content for websites.\n\n\n\n\n\n\n\n\n\n\nREADME\n\n\n\nA README file is the first thing someone looking at your code reads. It should contain a summary of the project and instructions for how to use it. The README should be clear and concise, and link to further documentation if more detail is required.",
    "crumbs": [
      "Coding Standards",
      "Documentation"
    ]
  },
  {
    "objectID": "documentation/index.html#medium-criticality",
    "href": "documentation/index.html#medium-criticality",
    "title": "Documentation",
    "section": "Medium Criticality",
    "text": "Medium Criticality\n\n\n\n\n\n\n\n\nDocstrings\n\n\n\nIt is good practice to document code as it is being developed. If code is well-structured into functions, classes and methods then each one should be documented separately. This makes using them clear to developers. the standard approach for this are docstrings.\n\n\n\n\n\n\n\n\n\n\nProcess Scripts\n\n\n\nWhen running complex processes, it is a good idea to have one or more scripts to run. These scripts, provide a simple high-level interface for users to set parameters and run each step of the process, without requiring much knowledge of Python or the project.",
    "crumbs": [
      "Coding Standards",
      "Documentation"
    ]
  },
  {
    "objectID": "documentation/index.html#high-criticality",
    "href": "documentation/index.html#high-criticality",
    "title": "Documentation",
    "section": "High Criticality",
    "text": "High Criticality\n\n\n\n\n\n\n\n\nProjects\n\n\n\nAll the documentation described exists within the project’s code. This encourages developers to update documentation as they change code. However, it is not very user friendly. For critical projects, a website should be created collating all the documentation.\n\n\n\n\n\n\n\n\n\n\nChange Log\n\n\n\nAs development occurs and changes are made, they should be tracked in GitHub. However, extracting a summary of changes from a commit history is not easy. A Changelog provides a brief summary of changes for each ask.",
    "crumbs": [
      "Coding Standards",
      "Documentation"
    ]
  },
  {
    "objectID": "documentation/process-scripts.html",
    "href": "documentation/process-scripts.html",
    "title": "Process Scripts",
    "section": "",
    "text": "When building and running processes, it is good practice to implement all the logic in functions, classes and methods (see [../coding-standards/factoring.qmd]). Running the process then becomes a series of steps, each calling a function or method. These steps should be detailed in a high-level process script.\n\n\n\n\n\n\nNote\n\n\n\nA process script should not contain any logic, it should just allow the user to set parameters and run the process by executing each step, one-by-one, or the whole process in a single step.",
    "crumbs": [
      "Coding Standards",
      "Documentation",
      "Process Scripts"
    ]
  },
  {
    "objectID": "documentation/process-scripts.html#what-is-a-process-script",
    "href": "documentation/process-scripts.html#what-is-a-process-script",
    "title": "Process Scripts",
    "section": "",
    "text": "When building and running processes, it is good practice to implement all the logic in functions, classes and methods (see [../coding-standards/factoring.qmd]). Running the process then becomes a series of steps, each calling a function or method. These steps should be detailed in a high-level process script.\n\n\n\n\n\n\nNote\n\n\n\nA process script should not contain any logic, it should just allow the user to set parameters and run the process by executing each step, one-by-one, or the whole process in a single step.",
    "crumbs": [
      "Coding Standards",
      "Documentation",
      "Process Scripts"
    ]
  },
  {
    "objectID": "documentation/process-scripts.html#what-format-should-a-process-script-use",
    "href": "documentation/process-scripts.html#what-format-should-a-process-script-use",
    "title": "Process Scripts",
    "section": "What format should a process script use?",
    "text": "What format should a process script use?\nQuarto is a good format to use for process scripts. It allows you mix documentation and code so you can explain each step and guide the user and they can execute the code by running the cell.",
    "crumbs": [
      "Coding Standards",
      "Documentation",
      "Process Scripts"
    ]
  },
  {
    "objectID": "documentation/process-scripts.html#example",
    "href": "documentation/process-scripts.html#example",
    "title": "Process Scripts",
    "section": "Example",
    "text": "Example\n# Awesome Process\n\n## Setup\n\nIn order to run this process the following packages must be installed, using\n[uv](../reproducibility/project-management/uv.qmd):\n\n```powershell\nuv add polars lloydsdb\n```\n\n## Parameters\n\nBefore running the process, review and update the following parameters:\n\n```python\nparams = {\n    \"return_year\": 2024,\n    \"min_yoa\": 2014,\n    \"threshold\": 0.2,\n}\n```\n\n## Run Process\n\n### Read Required Data\n\nRead the reserving data from the reserving database.\n\n```python\nfrom reserving_flags import read_reserving_data\n\nreserving_data = read_reserving_data(params[\"return_year\"], params[\"min_yoa\"])\n```\n\n### Calculate Flags\n\nCalculate the flags given the suppied threshold.\n\n```python\nfrom reserving_flags import calculate_flags\n\nflags = calculate_flags(reserving_data, params[\"threshold\"])\n```\n\n### Save Results\n\nSave results to the reserving database.\n\n```python\nfrom reserving_flags import save_flags\n\nsave_flags(flags)\n```",
    "crumbs": [
      "Coding Standards",
      "Documentation",
      "Process Scripts"
    ]
  },
  {
    "objectID": "documentation/readme.html",
    "href": "documentation/readme.html",
    "title": "README",
    "section": "",
    "text": "A well-written README file is the first impression your project makes. It’s the landing page for your repository, providing essential information to potential users and contributors. A clear, concise, and informative README can significantly impact the adoption and success of your project. This article outlines the key elements of a great README.",
    "crumbs": [
      "Coding Standards",
      "Documentation",
      "README"
    ]
  },
  {
    "objectID": "documentation/readme.html#writing-effective-readme-files",
    "href": "documentation/readme.html#writing-effective-readme-files",
    "title": "README",
    "section": "",
    "text": "A well-written README file is the first impression your project makes. It’s the landing page for your repository, providing essential information to potential users and contributors. A clear, concise, and informative README can significantly impact the adoption and success of your project. This article outlines the key elements of a great README.",
    "crumbs": [
      "Coding Standards",
      "Documentation",
      "README"
    ]
  },
  {
    "objectID": "documentation/readme.html#what-is-a-readme",
    "href": "documentation/readme.html#what-is-a-readme",
    "title": "README",
    "section": "What is a README?",
    "text": "What is a README?\nA README file (typically named README.md) is a plain text file that provides an overview of your project. It’s the first thing visitors see when they land on your project’s repository on GitHub.",
    "crumbs": [
      "Coding Standards",
      "Documentation",
      "README"
    ]
  },
  {
    "objectID": "documentation/readme.html#why-is-a-readme-important",
    "href": "documentation/readme.html#why-is-a-readme-important",
    "title": "README",
    "section": "Why is a README Important?",
    "text": "Why is a README Important?\n\nFirst Impression: It’s the initial introduction to your project, so it needs to be clear, concise, and engaging.\nOnboarding Users: It guides users on how to install, use, and contribute to your project.\nAttracting Contributors: A good README can encourage others to contribute to your project by providing clear guidelines.\nDocumentation Entry Point: It serves as a starting point for more detailed documentation.",
    "crumbs": [
      "Coding Standards",
      "Documentation",
      "README"
    ]
  },
  {
    "objectID": "documentation/readme.html#essential-elements-of-a-readme",
    "href": "documentation/readme.html#essential-elements-of-a-readme",
    "title": "README",
    "section": "Essential Elements of a README",
    "text": "Essential Elements of a README\n\nProject Title and Short Description: Start with the project’s name in a prominent heading (e.g., # My Project). Immediately follow with a brief, one-sentence description of what the project does.\n# Awesome Python Library\n\nA powerful and easy-to-use library for data analysis.\nInstallation Instructions: Clearly explain how to install your package. This usually involves using pip or uv:\n## Installation\n\n```bash\npip install your-package\n```\n\nor\n\n```bash\nuv add your-package\n```\nIf there are any dependencies or specific system requirements, mention them here.\nUsage Examples: Provide concise and practical examples demonstrating how to use your library. Code blocks are essential for this:\nimport your_package\n\ndata = your_package.load_data(\"data.csv\")\nresults = your_package.analyze(data)\nprint(results)\nIf you have more extensive examples, consider linking to a separate examples directory or documentation site.\nDocumentation Link: If you have more detailed documentation (generated by mkdocs, for example), provide a link to it.\n## Documentation\n\nFull documentation can be found at\n[https://connect/docs/projects](https://connect/docs/projects).",
    "crumbs": [
      "Coding Standards",
      "Documentation",
      "README"
    ]
  },
  {
    "objectID": "documentation/readme.html#formatting-and-style",
    "href": "documentation/readme.html#formatting-and-style",
    "title": "README",
    "section": "Formatting and Style",
    "text": "Formatting and Style\n\nUse Markdown: Markdown is the preferred format for README files on most platforms. It’s easy to read and write and supports basic formatting like headings, lists, code blocks, and links.\nKeep it Concise: Avoid unnecessary jargon or overly long explanations. Get to the point quickly.\nUse Headings and Subheadings: Structure your README with clear headings and subheadings to make it easy to navigate.\nUse Code Blocks: Use code blocks (using triple backticks ```) to display code examples clearly.\nUse Lists: Use lists for enumerating items or steps.\nProofread Carefully: Ensure your README is free of typos and grammatical errors.\n\nBy following these guidelines, you can create a compelling and informative README file that will help users and contributors understand and engage with your Python project. Remember, a good README is an investment that pays off in the long run.",
    "crumbs": [
      "Coding Standards",
      "Documentation",
      "README"
    ]
  }
]